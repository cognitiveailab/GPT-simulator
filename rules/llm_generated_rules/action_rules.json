{
    "make-campfire": "The Python program provided is a text-based simulation game where the player's task is to make a campfire in a forest environment. The game involves interacting with various objects (FirePit, Match, Axe, Tree) through a set of defined actions. Here's a breakdown of the actions, their constraints, and how they change the game state:\n\n### Actions\n\n1. **look/look around**: Provides a description of the current environment or the state of a specific object. No constraints. Does not change the game state.\n\n2. **inventory**: Lists the items currently held by the player. No constraints. Does not change the game state.\n\n3. **examine [object]**: Gives a detailed description of the specified object. No constraints. Does not change the game state.\n\n4. **take [object]**: Moves an object from the environment or a container into the player's inventory. Constraints include the object being movable and not currently on fire. Changes the game state by updating the location of the object.\n\n5. **put [object] in/on [container]**: Moves an object from the player's inventory to a specified container in the environment. Constraints include the container being open and the object being movable. Changes the game state by updating the location of the object.\n\n6. **open [container]**: Opens a container if it is closed. Constraints include the container being openable. Changes the game state by marking the container as open.\n\n7. **close [container]**: Closes a container if it is open. Constraints include the container being openable. Changes the game state by marking the container as closed.\n\n8. **turn on [device]/turn off [device]**: Turns a device on or off. Constraints include the device being activatable. Changes the game state by updating the device's on/off status.\n\n9. **use [device] on [object]**: Uses a device on an object. The constraints and effects vary depending on the device and object. For example, using an axe on a tree changes the tree into chopped down tree or firewood, and using a match on a fire pit with firewood starts a fire, potentially winning the game.\n\n### Game State Changes\n\n- **FirePit**: Can contain firewood. If firewood is placed within and lit, it changes the game state towards winning.\n- **Match**: Can be used to light firewood in the FirePit. Using a match consumes it, removing it from the game.\n- **Axe**: Can be used to chop a Tree into chopped down tree and then into firewood. The axe can also catch fire and become unusable if its combustion time runs out.\n- **Tree**: Can be chopped down into firewood by using an Axe. If set on fire, it can burn out, affecting the game's outcome.\n\n### Winning and Losing Conditions\n\n- **Winning**: The player successfully lights firewood in the FirePit, creating a campfire.\n- **Losing**: The player fails to create a campfire before the Tree burns out or if the game's critical objects are misused or destroyed.\n\nThis game emphasizes inventory management, object interaction, and understanding the properties and states of objects to achieve the goal of making a campfire.",
    "volume": "Based on the provided Python code for a text-based game, the game simulates an environment where the player's task is to measure and compute the volume of a box using a ruler. The game is set in a room that contains a number of boxes of different sizes and colors, along with a ruler. The player can interact with these objects through a set of defined actions. Here's a breakdown of each action, its constraints, and how it changes the game state:\n\n### Actions:\n\n1. **look/look around**: \n   - **Constraints**: No constraints; can be used at any time.\n   - **Game State Change**: Provides a description of the current environment, listing all visible objects.\n\n2. **inventory**: \n   - **Constraints**: No constraints; can be used at any time.\n   - **Game State Change**: Lists all items currently in the player's inventory.\n\n3. **examine [object]**: \n   - **Constraints**: The object must be present in the room or in the player's inventory.\n   - **Game State Change**: Provides a detailed description of the specified object.\n\n4. **take [object]**: \n   - **Constraints**: The object must be movable and not already in the player's inventory.\n   - **Game State Change**: Moves the specified object from the room to the player's inventory.\n\n5. **put [object] in/on [container]**: \n   - **Constraints**: The object must be in the player's inventory, and the container must be able to hold objects.\n   - **Game State Change**: Moves the specified object from the player's inventory to the specified container.\n\n6. **measure the [length/width/height] of the [object] with the [ruler]**: \n   - **Constraints**: The ruler must be in the player's inventory, and the object must be a box.\n   - **Game State Change**: Provides the measurement of the specified dimension of the box.\n\n7. **answer [volume]**: \n   - **Constraints**: The player must have determined the volume of the target box.\n   - **Game State Change**: The player submits their answer for the volume of the target box. If correct, the game ends successfully; otherwise, the game ends unsuccessfully.\n\n### Additional Notes:\n\n- The game uses a random seed to generate the sizes and colors of the boxes, making each game potentially different.\n- The game tracks the player's inventory, allowing for objects to be taken and used.\n- The game ends when the player submits an answer for the volume of the target box, with the outcome depending on the accuracy of the answer.\n- The game provides feedback on actions taken, including descriptions of objects and the environment, as well as the outcome of actions like measuring or moving objects.\n\nThis game emphasizes observation, deduction, and the application of basic geometry (length × width × height) to solve the problem of determining the volume of a specific box.",
    "boil-water": "The Python program provided is a text-based simulation game where the player's task is to boil water. The game environment is a kitchen, and the player interacts with various objects (e.g., stove, pot, water, sink) to accomplish the task. Here's a breakdown of the actions available in the game, their constraints, and how they change the game state:\n\n### Actions\n\n1. **Look/Look Around**: Allows the player to get a description of the current environment or a specific object. No constraints. It doesn't change the game state but provides information.\n\n2. **Inventory**: Lists the items currently held by the player. No constraints. It doesn't change the game state but provides information about the player's current items.\n\n3. **Examine**: Provides detailed information about a specific object. The constraint is that the object must be identifiable in the current context. It doesn't change the game state but gives more detailed information than \"look.\"\n\n4. **Take**: Moves an object from the environment (or a container within the environment) to the player's inventory. Constraints include the object being movable and accessible (e.g., not in a closed container). Changes the game state by updating the location of an object.\n\n5. **Put**: Places an object from the player's inventory into a container in the environment. Constraints include the container being open and the object being movable. Changes the game state by updating the location of an object.\n\n6. **Open/Close**: Changes the state of a container from open to closed or vice versa. Constraints include the object being a container and having the capability to be opened or closed. Changes the game state by updating the container's state.\n\n7. **Turn On/Turn Off**: Activates or deactivates a device (e.g., stove, sink). Constraints include the object being a device that can be turned on or off. Changes the game state by updating the device's state, which can affect other objects (e.g., heating water on a stove).\n\n8. **Eat**: Simulates the player eating an item. Constraints include the object being food. It changes the game state by removing the food item from the game.\n\n### Game State Changes\n\n- **Temperature Changes**: When the stove is turned on, it increases the temperature of objects on it, potentially changing their state (e.g., water to steam).\n- **Adding Water**: Turning on the sink adds water to containers in the sink, which is crucial for boiling water.\n- **Object Locations**: Taking and putting objects change their locations, which is essential for setting up conditions to boil water (e.g., putting the pot on the stove).\n- **Container States**: Opening and closing containers can restrict or allow access to their contents, affecting the player's ability to move objects.\n- **Device States**: Turning devices on or off can enable or disable their functions, such as heating or adding water.\n\n### Winning Condition\n\nThe game is won when water reaches its boiling point and turns into steam, indicated by the presence of \"steam\" in the environment. This requires the player to correctly use the stove and pot, demonstrating an understanding of the boiling water process.\n\n### Conclusion\n\nThe game simulates the task of boiling water through text-based interactions, requiring players to understand and manipulate the states of various objects within a kitchen environment. Each action has specific constraints and effects on the game state, leading to a goal-oriented gameplay experience focused on problem-solving.",
    "hang-painting": "The Python program provided is a text-based simulation game where the player's task is to hang a specific picture on a designated wall within a virtual environment. The game involves interacting with various objects, including a nail, a wall, a picture, and a hammer. Here's a detailed breakdown of the actions available in the game, their constraints, and how they change the game state:\n\n### Actions\n\n1. **Look Around (`look`, `look around`)**:\n   - **Constraints**: None.\n   - **Effect**: Provides a description of the current environment, including visible objects and their states.\n\n2. **Inventory (`inventory`)**:\n   - **Constraints**: None.\n   - **Effect**: Lists the items currently in the player's inventory.\n\n3. **Take (`take <object>`)**:\n   - **Constraints**: The object must be in the same container (room) as the player and must be movable.\n   - **Effect**: Moves the specified object from the room to the player's inventory.\n\n4. **Put (`put <object> in/on <container>`)**:\n   - **Constraints**: The player must have the object in their inventory, and the target container must be in the same room and capable of holding objects.\n   - **Effect**: Moves the specified object from the player's inventory to the target container.\n\n5. **Hammer (`hammer <nail> on <wall> with <hammer>`)**:\n   - **Constraints**: The player must have both the nail and the hammer in their inventory. The wall must be present in the room.\n   - **Effect**: Attaches the nail to the specified wall, allowing a picture to be hung on it.\n\n6. **Hang (`hang <picture> on <nail>`)**:\n   - **Constraints**: The player must have the picture in their inventory, and the nail must be hammered into a wall.\n   - **Effect**: Hangs the picture on the nail, potentially completing the game's objective if it's the correct picture and wall.\n\n### Game State Changes\n\n- **Taking an object** changes its location from the room to the player's inventory.\n- **Putting an object in a container** changes its location from the player's inventory to the specified container.\n- **Hammering a nail into a wall** changes the state of the nail to being attached to the wall.\n- **Hanging a picture on a nail** changes the location of the picture to being on the nail, and if the conditions are met (correct picture and wall), it may trigger the completion of the game's objective.\n\n### Additional Notes\n\n- The game keeps track of the player's actions, inventory, and the state of the environment.\n- The game ends when the player successfully hangs the specified picture on the designated wall, or potentially if an incorrect action is taken (e.g., hammering a nail into the wrong wall).\n- The game provides feedback after each action, including descriptions of the environment, the results of actions, and the current game state (score, steps taken, whether the game is over, and whether the player has won).\n\nThis simulation game emphasizes understanding and manipulating object relationships within a constrained environment to achieve a specific goal.",
    "metal-detector": "The Python program provided is a text-based simulation game where the player uses a metal detector to find a buried metal item on a beach. The game involves moving around different locations on the beach, using a metal detector to detect buried items, and digging them up with a shovel. Here's a breakdown of the actions described in the code, their constraints, and how they change the game state:\n\n### Actions\n\n1. **Look Around (`look`, `look around`)**: This action allows the player to get a description of their current location, including visible items and directions to move. There are no constraints for using this action.\n\n2. **Inventory (`inventory`)**: Displays the items currently in the player's inventory. This action can be performed at any time without constraints.\n\n3. **Take (`take <item>`)**: Allows the player to pick up an item from their current location and add it to their inventory. The constraint here is that the item must be present in the location and not buried.\n\n4. **Put (`put <item> in <container>`)**: This action lets the player place an item from their inventory into a container in their current location. The constraints include having the item in the inventory and the container being present and open in the location.\n\n5. **Move (`move <direction>`)**: Moves the player to a different location based on the specified direction (north, east, south, west). The constraint is that there must be a path in the specified direction from the current location.\n\n6. **Detect (`detect with <metal detector>`)**: Uses the metal detector to check if there are any metal items buried in the current location. The player must have the metal detector in their inventory to use this action.\n\n7. **Dig (`dig with <shovel>`)**: Digs up the current location to find buried items. The player needs to have a shovel with remaining durability in their inventory. Digging reduces the shovel's durability by 1. If a metal item is detected, this action will uncover it.\n\n### Game State Changes\n\n- **Taking and putting items** changes the inventory and the items present in the current location.\n- **Moving** changes the player's current location.\n- **Detecting** does not change the game state but provides information about buried items.\n- **Digging** can change the items present in the location by uncovering buried items. It also affects the shovel's durability.\n\n### Winning Condition\n\nThe player wins the game by finding and taking the buried metal case into their inventory. The game keeps track of the number of steps taken, the current score, and whether the game has been won or is over.\n\n### Additional Notes\n\n- The game uses a random seed to initialize the world, including the starting location of the player, the location of the metal case, and other items.\n- The game supports a dynamic action system where the available actions are generated based on the current game state, such as the items present and the player's inventory.\n- The game includes a main loop where the player can input actions, and the game responds with the outcome of those actions, updating the game state accordingly.",
    "forge-key": "The Python program provided is a text-based simulation game where the player's objective is to forge a key using a mold and open a locked door. The game environment is a workshop containing various objects that interact with each other based on the actions performed by the player. Here's a detailed breakdown of the actions available in the game, their constraints, and how they change the game state:\n\n### Actions\n\n1. **Look/Look Around**: \n   - **Constraints**: None.\n   - **Effect**: Provides a description of the current environment, listing all visible objects and their states.\n\n2. **Inventory**: \n   - **Constraints**: None.\n   - **Effect**: Lists all items currently held by the player.\n\n3. **Take [Object]**: \n   - **Constraints**: The object must be movable and, if a substance, in a solid state.\n   - **Effect**: Moves an object from its current location to the player's inventory.\n\n4. **Put [Object] in/on [Container]**: \n   - **Constraints**: The object must be in the player's inventory, and the container must be open and capable of holding the object.\n   - **Effect**: Moves an object from the player's inventory to the specified container.\n\n5. **Open [Container/Door]**: \n   - **Constraints**: The object must be openable. If it's a door and locked, a key must be used.\n   - **Effect**: Changes the state of a container or door to open.\n\n6. **Close [Container/Door]**: \n   - **Constraints**: The object must be openable.\n   - **Effect**: Changes the state of a container or door to closed.\n\n7. **Turn On [Device]**: \n   - **Constraints**: The object must be a device capable of being turned on (e.g., HeatSource).\n   - **Effect**: Activates a device, which may start changing the temperature of objects within it.\n\n8. **Turn Off [Device]**: \n   - **Constraints**: The object must be a device capable of being turned off.\n   - **Effect**: Deactivates a device, stopping any temperature changes.\n\n9. **Pour [Liquid] into [Container]**: \n   - **Constraints**: The liquid must be in a liquid state, and the container must be capable of holding liquids.\n   - **Effect**: Moves a liquid substance from its current location to a specified container, potentially changing its shape if poured into a mold.\n\n### Game State Changes\n\n- **HeatSource**: When turned on, increases the temperature of contained objects each tick until reaching its max temperature. This can change the state of substances (e.g., melting a copper ingot).\n- **Mold**: When a liquid substance is poured into it, the substance takes the shape of the mold. The mold also changes the temperature of its contents towards room temperature each tick, potentially solidifying liquid substances.\n- **Substance**: Changes state (solid, liquid, gas) based on temperature. This affects its name and whether it can be taken or poured.\n- **Door**: Can be opened if unlocked. If locked, requires a key shaped by a mold to open.\n\n### High-Level Solution Procedure\n\n1. Take the copper ingot.\n2. Put the copper ingot in the foundry.\n3. Turn on the foundry and wait until the copper melts.\n4. Pour the melted copper into the key mold.\n5. Wait until the copper cools down and solidifies into a key.\n6. Take the copper key.\n7. Open the door with the copper key.\n\nThis game demonstrates object-oriented programming principles, inheritance, and polymorphism through the interactions between different classes and objects within the game environment.",
    "blood-type": "The Python program provided simulates a text-based game where the player acts as a nurse in an emergency room, tasked with giving the correct type of blood to a patient. The game involves managing objects within the game world, specifically patients and blood bags, each with specific blood types. Here's a breakdown of the actions described in the comments and how they affect the game state:\n\n### Actions:\n1. **look/look around**: Allows the player to get a description of the current environment, including objects present in the room. This action does not change the game state but provides information to the player.\n\n2. **inventory**: Displays the items currently held by the player (in the agent's inventory). This action is purely informational and does not alter the game state.\n\n3. **take [object]**: Moves an object from the environment (or from within another object if it's a container) into the player's inventory. This action changes the game state by altering the location of an object. Constraints include the object being movable and accessible (not inside a closed container).\n\n4. **put [object] in/on [container]**: Moves an object from the player's inventory into a container in the environment. This action changes the game state by altering the location of an object. Constraints include the container being openable and open, and the object being movable.\n\n5. **give [blood] to [patient]**: This action is the core task of the game, where the player gives a bag of blood to a patient. The game checks if the blood type of the given blood matches the patient's requirements. If the match is correct, the game is won; otherwise, it's lost. This action changes the game state significantly by potentially ending the game. Constraints include the blood being in the player's inventory and matching the patient's blood type and Rh factor requirements.\n\n### Constraints and State Changes:\n- **Objects** (blood bags and patients) have specific properties like blood type and Rh factor, which are critical for the game's main task.\n- **Containers** can be objects in which other objects can be placed. Their state can be changed from open to closed, and they can contain or release objects.\n- **Inventory Management**: The player has an inventory for carrying objects. The state of the inventory changes as objects are added or removed.\n- **Game End Conditions**: The game ends when the player gives blood to the patient. The outcome (win/lose) depends on whether the blood type given matches the patient's needs.\n\n### Game Flow:\n- The game initializes with a random patient requiring a specific blood type and Rh factor, and a selection of blood bags with various types.\n- The player explores the environment, gathers information, and decides which blood bag to give to the patient.\n- The player's actions, especially the choice of blood to give, directly influence the game's outcome.\n\nThis game emphasizes inventory management, object interaction, and making choices based on the game world's state and the properties of objects within it.",
    "use-bandage": "The Python program provided is a text-based simulation game where the player's objective is to apply bandages to any wounds found on a person's body parts. The game is set in a bathroom environment and involves interacting with various objects, including a BandageBox, Bandages, a Person, and BodyParts, among others. Here's a detailed breakdown of the actions available in the game, their constraints, and how they change the game state:\n\n### Actions:\n\n1. **look/look around**: Allows the player to get a description of the current environment, listing all visible objects and their states. There are no constraints for this action, and it does not change the game state.\n\n2. **inventory**: Displays the items currently held by the player (in the agent's inventory). This action has no constraints and does not alter the game state.\n\n3. **examine [object]**: Provides a detailed description of the specified object. This action requires the object to be visible to the player but does not change the game state.\n\n4. **take [object]**: Moves an object from its current location into the player's inventory. This action is constrained by the object being movable and the player being able to access it (e.g., the container holding the object must be open). Successfully taking an object changes the game state by updating the object's location.\n\n5. **put [object] in/on [container/body part]**: Transfers an object from the player's inventory to a specified container or body part. This action is constrained by the object being in the player's inventory and the target container/body part being accessible and appropriate for the object. This action changes the game state by updating the object's location.\n\n6. **open [container]**: Opens a container if it is closed and is openable. This action is constrained by the container being closed and capable of being opened. Successfully opening a container changes its state to open.\n\n7. **close [container]**: Closes an open container. This action requires the container to be open and capable of being closed. Successfully closing a container changes its state to closed.\n\n### Constraints and State Changes:\n\n- **Containers** (e.g., BandageBox) must be open for objects to be taken from or placed within them. Opening or closing a container changes its \"isOpen\" property.\n- **Objects** must be movable (property \"isMoveable\" = True) to be taken or put. Moving an object changes its \"parentContainer\" property.\n- **Body Parts** can have a \"hasWound\" property. Applying a bandage to a wounded body part is the primary objective. The game checks for bandages on wounded body parts to determine if the game has been won.\n- **Bandages** can be applied to body parts, changing the state of the body part by indicating it has been treated.\n- **Distractor Items** (e.g., Sticker, Clothing) do not directly contribute to the game's objective but can be interacted with similarly to critical items.\n\n### Winning Condition:\n\nThe game is won when all body parts with wounds have bandages applied to them. This is determined during the score calculation phase, where the game checks each BodyPart object for wounds and bandages. Successfully bandaging all wounds sets the \"gameOver\" and \"gameWon\" flags to True.\n\nThis simulation game teaches basic inventory management and object interaction within a constrained environment, focusing on achieving a specific task through a series of actions and state changes.",
    "conductivity": "The Python program provided simulates a text-based game where the player's objective is to test the conductivity of a fork by incorporating it into an electrical circuit. The game environment consists of a room containing various objects, including a battery, a light bulb, wires, a fork, and two boxes (red and black). The player interacts with the game through a set of defined actions, manipulating objects to achieve the goal. Here's a breakdown of the actions and their effects on the game state:\n\n### Actions\n\n1. **Look/Look Around**\n   - **Constraints:** None.\n   - **Effect:** Provides a description of the current environment, listing all visible objects and their states.\n\n2. **Inventory**\n   - **Constraints:** None.\n   - **Effect:** Lists all items currently in the player's inventory.\n\n3. **Take [Object]**\n   - **Constraints:** The object must be present in the current environment and not already in the player's inventory.\n   - **Effect:** Moves the specified object from the environment into the player's inventory. If the object is an electrical object, all its connections are removed.\n\n4. **Put [Object] in/on [Container]**\n   - **Constraints:** The object must be in the player's inventory, and the target must be a container present in the environment.\n   - **Effect:** Moves the specified object from the player's inventory into the specified container.\n\n5. **Connect [Object1] [Terminal1] to [Object2] [Terminal2]**\n   - **Constraints:** Both objects must be electrical objects, and at least one of them must be a wire. The specified terminals must exist on the respective objects.\n   - **Effect:** Establishes an electrical connection between the specified terminals of the two objects. If a terminal is already connected, the existing connection is removed before establishing the new one.\n\n### Game State Changes\n\n- **Electrical Connections:** Connecting objects affects the circuit's state, which in turn influences whether the light bulb turns on. The game checks for a complete circuit including the battery, the fork, and the light bulb. If such a circuit exists and is conductive (i.e., the fork is conductive), the light bulb's state changes to \"on.\"\n  \n- **Light Bulb State:** The state of the light bulb (on/off) is updated based on the circuit's completeness and conductivity. This state is crucial for determining the fork's conductivity.\n\n- **Object Locations:** Taking and putting objects change their locations, affecting the player's ability to use them in the circuit or place them in the correct box based on the fork's conductivity.\n\n- **Game End Conditions:** The game concludes when the fork is placed in either the red or black box. The game is won if the fork is placed in the correct box according to its conductivity (red if conductive, black if not). The score and game state (won/lost) are updated accordingly.\n\n### Additional Notes\n\n- The game employs a tick system (`tick()` method in objects) to update the state of objects based on the environment's current state, such as checking the light bulb's state.\n  \n- The game's outcome is determined by the player's actions, specifically how they manipulate the objects to test the fork's conductivity and where they decide to place the fork based on their findings.\n\nThis simulation offers an interactive way to understand basic electrical concepts and logical problem-solving within a constrained environment.",
    "space-walk": "The Python program provided is a text-based simulation game where the player conducts a spacewalk. The game involves navigating through rooms (spaceship, airlock, outer space), managing doors (opening and closing them), and wearing a spacesuit to survive in outer space. Here's a breakdown of the actions described in the comments and how they affect the game state:\n\n### Actions\n\n1. **Look**: Allows the player to get a description of their current environment, including visible objects and doors. This action does not change the game state but provides information to the player.\n\n2. **Inventory**: Displays the items currently carried by the player. Like \"look,\" it does not alter the game state but informs the player about their resources.\n\n3. **Take/Put Objects**: \n   - **Take**: Moves an object from the current room (or container) to the player's inventory. This action changes the game state by altering the location of an object. Constraints include the object being movable and the container (if any) being open.\n   - **Put**: Places an object from the player's inventory into a specified container or room. Constraints include the target being a container and it being open. This action also changes the game state by altering the location of an object.\n\n4. **Move to a Room**: Changes the player's current location to a specified room. Constraints include the target room being directly connected to the current room and any connecting door being open. This action significantly changes the game state by updating the player's location.\n\n5. **Put on Object (Space Suit)**: This specific action allows the player to wear the space suit, which is critical for surviving in outer space. The constraint is that the object must be a space suit. This action changes the game state by updating the player's status to wearing the space suit.\n\n6. **Open/Close Door**: \n   - **Open**: Changes the state of a door from closed to open, provided the door is in the current room. This action alters the game state by potentially allowing access to new areas.\n   - **Close**: Changes the state of a door from open to closed, with the same constraints as opening. This action can prevent access to areas and is crucial for managing the spaceship's connection to outer space.\n\n### Constraints and State Changes\n\n- **Rooms** have properties like being outer space or not, and they can contain objects including doors.\n- **Doors** can be open or closed, affecting the player's ability to move between rooms.\n- **The Space Suit** is critical for surviving in outer space. Without it, the player dies if they enter outer space or if outer space becomes directly connected to the spaceship without an airlock in between.\n- **Objects** can be movable or immovable, and containers can be open or closed. These properties determine the feasibility of take/put actions.\n\n### Game State\n\nThe game state includes the player's current location, inventory contents, whether the player is wearing a space suit, and the open/closed status of doors. Actions like moving, taking/putting objects, and wearing the space suit directly alter the game state. The game also tracks whether the player has died or successfully completed the game by conducting a spacewalk and returning safely.\n\n### Winning and Losing Conditions\n\n- The player wins by successfully moving to outer space while wearing the space suit and then returning.\n- The player loses if they enter outer space without a space suit or if the spaceship becomes directly connected to outer space without an airlock in between, leading to the player's death.\n\nThis game emphasizes exploration, resource management, and understanding the environment to successfully conduct a spacewalk and return safely.",
    "wash-clothes": "The provided Python program simulates a text-based game where the player's task is to wash and dry clothes using a washing machine and a dryer. The game environment includes a room with various objects such as a WashingMachine, Dryer, Clothes, DetergentBottle, Detergent, and Basket. Here's a detailed description of the actions available in the game, their constraints, and how they change the game state:\n\n### Actions\n\n1. **look/look around**: Allows the player to get a description of the current environment or room, listing all visible objects and their states. No constraints.\n\n2. **inventory**: Displays the items currently held by the player (in the agent's inventory). No constraints.\n\n3. **wait**: Advances the game by one tick without the player doing anything. This can be used to wait for the washing machine or dryer cycles to complete. No constraints.\n\n4. **examine [object]**: Provides a detailed description of the specified object, including its state (e.g., open/closed for containers, on/off for devices, clean/dirty and wet/dry for clothes). The object must be visible to the player.\n\n5. **take [object]**: Moves an object from its current location to the player's inventory. The object must be movable and accessible (not inside a closed container).\n\n6. **put [object] in/on [container]**: Moves an object from the player's inventory to a specified container. The container must be open or openable.\n\n7. **open [container]**: Opens a container if it is closed and openable. The container becomes accessible for putting in or taking out objects.\n\n8. **close [container]**: Closes an open container. Objects inside cannot be accessed until it is opened again.\n\n9. **turn on [device]**: Activates a device (e.g., washing machine, dryer) if it is not already on. The device must be closed to be turned on.\n\n10. **turn off [device]**: Deactivates a device if it is currently on. No constraints.\n\n11. **use [object] on [target]**: Applies an object to a target, such as adding detergent to the washing machine. Specific constraints apply depending on the objects involved.\n\n### Constraints and State Changes\n\n- **Washing Machine**: Must be closed and have detergent to wash clothes. It goes through cycles, changing clothes from dirty to clean and wet. Opening it resets its cycle.\n  \n- **Dryer**: Must be closed to operate. It dries wet clothes over its cycle. Opening it resets its cycle.\n\n- **Clothes**: Can be dirty, clean, wet, or dry. Their state changes based on interactions with the washing machine and dryer.\n\n- **DetergentBottle**: Used on the washing machine to add detergent, enabling the washing of clothes.\n\n- **Basket**: Serves as a container for clean and dry clothes, completing the game task when all clothes are clean, dry, and placed in it.\n\n### Game Progression\n\nThe game progresses through actions that change the state of the environment and objects within it. The player's goal is to successfully wash and dry all clothes, placing them in the basket to win the game. The game keeps track of steps, score, and whether the game has been won or lost based on the player's actions and the resulting state of the clothes and devices.",
    "mix-paint": "The Python program provided is a text-based simulation game where the player's task is to mix paints in an art studio environment to create a target color. The game involves interacting with objects such as cups and paints, and performing actions to achieve the goal. Here's a breakdown of the actions available in the game, their constraints, and how they change the game state:\n\n### Actions:\n\n1. **look/look around**: \n   - **Constraints**: No constraints; can be performed at any time.\n   - **Effect**: Provides a description of the current environment, listing all visible objects and their states.\n\n2. **inventory**: \n   - **Constraints**: No constraints; can be performed at any time.\n   - **Effect**: Lists all items currently held by the player (in the agent's inventory).\n\n3. **examine [object]**: \n   - **Constraints**: The object must be visible to the player or in their inventory.\n   - **Effect**: Provides detailed information about the specified object.\n\n4. **take [object]**: \n   - **Constraints**: The object must be movable and not already in the player's inventory.\n   - **Effect**: Moves the specified object from its current location into the player's inventory.\n\n5. **put [object] in/on [container]**: \n   - **Constraints**: The object must be in the player's inventory, and the target must be a container that is open or openable.\n   - **Effect**: Moves the specified object from the player's inventory into the specified container.\n\n6. **mix [container]**: \n   - **Constraints**: The container must contain two or more paints.\n   - **Effect**: Mixes the paints in the specified container, potentially creating a new color if the combination matches predefined color mixing rules.\n\n7. **pour [liquid] in/on [container]**: \n   - **Constraints**: The liquid must be a paint, and the target container must be capable of holding liquids.\n   - **Effect**: Moves the specified liquid from its current container into the target container.\n\n### Game State Changes:\n\n- **Objects and Containers**: The game world consists of objects (e.g., paints, cups) that can be manipulated by the player. Containers (e.g., cups) can hold other objects, and their contents can be altered by actions such as \"take\", \"put\", and \"pour\".\n- **Inventory Management**: The player has an inventory for holding objects. Actions like \"take\" and \"put\" move objects between the environment and the inventory.\n- **Mixing Paints**: The \"mix\" action changes the state of a container by potentially creating a new paint color based on the colors of the paints it contains. This is critical for achieving the game's goal of creating a target color.\n- **Game Progression**: The game tracks the number of steps taken by the player and adjusts the score based on the player's actions, particularly the creation of the target paint color. Successfully creating the target color marks the game as won.\n\n### Additional Notes:\n\n- The game uses a random seed to determine the target color at the start, adding variability to each playthrough.\n- The game's state is updated through actions, and feedback is provided to the player in the form of textual descriptions of the current state, observations after actions, and the inventory contents.\n- The game continues until the player successfully mixes the target color, at which point the game ends, and the player wins.\n\nThis simulation game emphasizes object interaction and logical problem-solving within a constrained environment, offering a creative twist on text-based adventure games.",
    "thermometer": "The Python program provided is a text-based simulation game where the player's task is to measure the temperature of water in a pot using a thermometer. The game is set in a kitchen environment and involves various game objects such as containers, liquids, and a thermometer. Here's a detailed description of the actions available in the game, their constraints, and how they change the game state:\n\n### Actions\n\n1. **Look/Look Around**\n   - **Constraints**: No constraints; can be done at any time.\n   - **Effect**: Provides a description of the current environment, listing all visible objects and their states.\n\n2. **Inventory**\n   - **Constraints**: No constraints; can be done at any time.\n   - **Effect**: Lists all items currently in the player's inventory.\n\n3. **Examine [object]**\n   - **Constraints**: The object must be visible to the player or in their inventory.\n   - **Effect**: Provides detailed information about the specified object.\n\n4. **Take [object]**\n   - **Constraints**: The object must be movable and not currently held in the player's inventory. Liquids cannot be taken directly.\n   - **Effect**: Moves the specified object from its current location into the player's inventory.\n\n5. **Put [object] in/on [container]**\n   - **Constraints**: The object must be in the player's inventory, and the container must be able to hold objects. The container must also be open if it is openable.\n   - **Effect**: Moves the specified object from the player's inventory into the specified container.\n\n6. **Use [object1] on [object2]**\n   - **Constraints**: Object1 must be a thermometer, and it must be in the player's inventory. Object2 cannot be the agent (player) or the thermometer itself.\n   - **Effect**: If Object2 is a liquid or a liquid container with liquid, it returns the temperature of the liquid. Otherwise, it indicates that the thermometer cannot be used on Object2.\n\n7. **Answer [temperature]**\n   - **Constraints**: The player must have determined the temperature of the water.\n   - **Effect**: The player submits their answer for the water's temperature. The game ends, and the player wins if the answer is correct; otherwise, the player loses.\n\n### Game State Changes\n\n- **Taking and Putting Objects**: Changes the location of objects between the environment, containers, and the player's inventory. This can affect the player's ability to use certain objects (e.g., the thermometer must be in the inventory to use it).\n- **Using the Thermometer**: Does not change the state of the game world but provides information critical for solving the game's task.\n- **Answering**: Ends the game. The game state changes to either won or lost based on the correctness of the player's answer regarding the water's temperature.\n\n### Additional Notes\n\n- The game includes distractor items and containers to add complexity. These do not directly contribute to completing the game's main task but can be interacted with similarly to task-critical objects.\n- The game's environment is dynamic, with the possibility of adding or removing objects, opening or closing containers, and changing the contents of containers.\n- The game tracks the player's actions, updating the game state and possible actions based on the current state of the game world and the objects within it.",
    "inclined-plane": "The provided Python program defines a text-based simulation game where the player's task is to determine which of two inclined planes has more friction by using a block and a stopwatch. Here's a breakdown of the actions described in the comments and how they affect the game state:\n\n### Actions\n\n1. **Look**: Allows the player to get a description of their current environment or a specific object. This action does not change the game state but provides information to the player.\n\n2. **Inventory**: Displays the items currently held by the player. This action also does not change the game state but informs the player about their possessions.\n\n3. **Examine**: Similar to \"look,\" but focused on a specific object, potentially providing detailed information. This action is informational and does not alter the game state.\n\n4. **Take/Put Objects**: These actions allow the player to interact with objects by moving them between their inventory and the environment (or within the environment). Taking an object moves it to the player's inventory, changing the game state by altering the location of the object. Putting an object changes its location to the specified container or location in the environment.\n\n5. **Activate/Deactivate/Reset Stopwatch**: These actions control the state of the stopwatch object. Activating the stopwatch starts its timer, deactivating stops it, and resetting it clears the current time. These actions change the game state by modifying the stopwatch's properties.\n\n6. **Focus on Object**: This action allows the player to select an inclined plane as their answer to the task of determining which has more friction. This action changes the game state by recording the player's choice.\n\n### Constraints and State Changes\n\n- **Taking and Putting Objects**: Objects can only be taken if they are movable and not already in the player's inventory. Objects can only be put in containers that are open and capable of holding items. These actions change the locations of objects within the game world.\n\n- **Stopwatch Actions**: The stopwatch must be in the player's inventory to be activated, deactivated, or reset. Activating the stopwatch starts counting time (ticks), deactivating it stops the counting, and resetting it clears the count. These actions modify the stopwatch's state but do not directly affect other objects or the environment.\n\n- **Focus on Object**: This action requires the player to choose one of the inclined planes based on their observations and experiments with the block and stopwatch. This action changes the game state by setting the player's answer to the task.\n\n### Game State Changes\n\n- The game state is primarily changed through the manipulation of objects (taking, putting, activating, etc.) and the selection of the inclined plane with more friction.\n- The game keeps track of the objects in the player's inventory, the state of the stopwatch, and the player's selected answer.\n- The game progresses through ticks, with certain actions (like activating the stopwatch) depending on the passage of time.\n- The game concludes when the player focuses on an inclined plane as their answer, determining if they have won based on their choice.\n\nThis simulation game combines elements of exploration, observation, and hypothesis testing, requiring players to interact with objects and make decisions based on the outcomes of their actions.",
    "clean-energy": "The Python program provided is a text-based simulation game where the player's objective is to convert all fossil-fuel power stations in various regions to renewable energy sources while maintaining the same energy capacity. Here's a detailed breakdown of the actions available in the game, their constraints, and how they change the game state:\n\n### Actions\n\n1. **Look (or Look Around)**\n   - **Constraints:** None. This action can be performed at any time.\n   - **Effect:** Provides the player with a description of the current state of the world, including the number of regions, the type of power plant in each region, and the renewable resource available in that region.\n\n2. **Change Region X to Powerplant A**\n   - **Constraints:** The action requires specifying a valid region and a valid type of power plant (solar farm, wind farm, hydroelectric power station, or fossil-fuel power station).\n   - **Effect:** Changes the type of power plant in the specified region to the new type. If the new power plant type does not match the region's renewable resource, the power plant operates at 10% efficiency. Otherwise, it operates at 100% efficiency. This action directly impacts the game's objective by potentially moving the player closer to converting all power plants to renewable energy sources.\n\n### Game State Changes\n\n- **Regions and Power Plants:** The game world consists of a number of regions, each with a power plant. The type of power plant and its efficiency can be changed through player actions, affecting the game's outcome.\n- **Score and Game Over Conditions:** The game calculates a score based on the player's actions, specifically whether all power plants have been converted to renewable energy sources and whether the total energy capacity meets the game's requirements. The game ends (and can be won) when all power plants are using renewable energy, and the total capacity is equal to or greater than the required capacity.\n- **Efficiency and Capacity:** Changing a power plant to a type that matches the region's renewable resource results in 100% efficiency, while a mismatch results in only 10% efficiency. This directly affects whether the game's capacity requirements can be met.\n\n### Additional Notes\n\n- The game initializes with a random number of regions and a mix of power plant types, ensuring varied gameplay.\n- The player's actions, particularly the choice of power plant for each region, are crucial in meeting the game's objectives.\n- The game provides feedback on the current state, including descriptions of each region, the efficiency and capacity of power plants, and the overall progress towards the game's goal.\n\nThis simulation game emphasizes strategic decision-making regarding energy sources, highlighting the importance of matching renewable energy types to available resources to achieve efficiency and capacity goals.",
    "volume-stone": "The Python program provided simulates a text-based game where the player's objective is to determine the volume of a stone using a measuring cup and a sink. The game involves interacting with objects in a virtual environment through a set of defined actions. Here's a breakdown of the actions, their constraints, and how they change the game state:\n\n### Actions\n\n1. **Look/Look Around**: \n   - **Constraints**: None.\n   - **Effect**: Provides a description of the current environment or room, listing all visible objects.\n\n2. **Inventory**: \n   - **Constraints**: None.\n   - **Effect**: Lists all items currently held by the player (in the agent's inventory).\n\n3. **Take [Object]**: \n   - **Constraints**: The object must be in the same container as the player or in a container within the player's current environment. The object must be movable.\n   - **Effect**: Moves the specified object from its current location into the player's inventory.\n\n4. **Put [Object] in/on [Container]**: \n   - **Constraints**: The player must be holding the object. The target container must be able to hold objects.\n   - **Effect**: Moves the specified object from the player's inventory into the specified container.\n\n5. **Turn On [Object]** / **Turn Off [Object]**: \n   - **Constraints**: The object must be activatable (e.g., the sink).\n   - **Effect**: Changes the state of the object to on or off. For the sink, turning it on will start filling any container placed within it with water.\n\n6. **Pour [Liquid] into [Container]**: \n   - **Constraints**: The liquid must be in a container that the player is holding or within reach. The target container must be able to hold liquids.\n   - **Effect**: Transfers the specified liquid from its current container to the target container. If the target container's volume is less than the volume of the liquid, it will only fill up to its maximum capacity.\n\n7. **Examine [Object]**: \n   - **Constraints**: The object must be within the player's current environment or in the player's inventory.\n   - **Effect**: Provides a detailed description of the object, including its properties and contents if it's a container.\n\n8. **Answer [Volume]**: \n   - **Constraints**: The player must input a numerical value representing the volume.\n   - **Effect**: The player submits their guess for the stone's volume. The game ends, and the player wins if the guess is correct.\n\n### Game State Changes\n\n- **Taking and Putting Objects**: Changes the location of objects between the environment, containers, and the player's inventory.\n- **Turning On/Off the Sink**: Affects whether water is being added to containers within the sink.\n- **Pouring Liquid**: Changes the distribution of liquid between containers, potentially affecting the game's outcome if used to measure the stone's volume.\n- **Answering**: Ends the game with a win or loss based on the accuracy of the player's guess regarding the stone's volume.\n\n### Additional Mechanics\n\n- **Water Volume Calculation**: When the sink is turned on, water is added to containers within it, simulating the filling process. The game likely uses this mechanic in conjunction with the measuring cup to determine the stone's volume by displacement.\n- **Game Tick**: The game appears to have a ticking mechanism where certain actions, like the sink filling a container with water, happen over time or steps rather than instantly. This is managed by the `tick` method in various objects.\n\nThis game emphasizes logical reasoning and understanding of volume measurement principles, requiring players to interact with the environment thoughtfully to achieve the goal.",
    "bird-life-cycle": "The Python program provided simulates a text-based game where the player takes on the role of a mother bird tasked with hatching an egg and raising the baby bird to adulthood. The game is set in a nest environment and involves interacting with objects (in this case, the egg and the bird at different life stages) through a set of defined actions. Here's a breakdown of the actions, their constraints, and how they affect the game state:\n\n### Actions\n\n1. **look (or look around)**: \n   - **Constraints**: None. This action can be performed at any time.\n   - **Effect**: Provides a description of the current environment, including the nest and its contents (e.g., the egg or bird in its current stage).\n\n2. **inventory**: \n   - **Constraints**: None. This action can be performed at any time.\n   - **Effect**: Lists the items currently in the player's inventory. In this game, the inventory functionality is present but not utilized for any specific items.\n\n3. **sing**: \n   - **Constraints**: None. This action can be performed at any time.\n   - **Effect**: A distractor action with no effect on the game state. It's meant to add flavor to the game.\n\n4. **fly around**: \n   - **Constraints**: None. This action can be performed at any time.\n   - **Effect**: Another distractor action with no effect on the game state, adding to the immersive experience.\n\n5. **sit on [object]**: \n   - **Constraints**: The object must be an egg.\n   - **Effect**: Increases the warmth of the egg, which is necessary for it to hatch. If the egg is not kept warm (warmth drops to 0), it will die. Successfully sitting on the egg until it hatches transitions the egg to the \"young bird\" stage.\n\n6. **feed [object]**: \n   - **Constraints**: The object must be a young bird.\n   - **Effect**: Increases the food level of the young bird, which is necessary for it to grow. If the young bird is not fed (food drops to 0), it will die. Successfully feeding the young bird until it grows transitions it to the \"adult bird\" stage.\n\n### Game State Changes\n\n- The game progresses through ticks, with each tick representing a time step in the game. During each tick, the egg and young bird's warmth and food levels, respectively, decrease by 1. The egg also gains 1 hatch point per tick, and the young bird gains 1 growth point per tick.\n- An egg needs to accumulate 5 hatch points to become a young bird, provided it has not died due to lack of warmth. Similarly, a young bird needs to accumulate 5 growth points to become an adult bird, provided it has not died due to lack of food.\n- The game is won when the bird reaches the \"adult bird\" stage. The game is lost if the egg dies (warmth reaches 0 before hatching) or the young bird dies (food reaches 0 before growing into an adult).\n\n### Additional Notes\n\n- The game includes a scoring system, though the specifics of score calculation beyond winning or losing are not detailed in the provided code.\n- The game ends when the player either successfully raises the bird to adulthood or fails by letting the egg or young bird die.\n- The game includes functionality for managing objects and containers, though the primary focus is on the bird's life cycle.\n\nThis simulation offers a simplified model of care and growth, engaging the player in the life cycle of a bird through interactive text-based gameplay.",
    "scale-weigh": "The Python program provided is a text-based game that simulates the task of weighing an object with a scale. The game is set in a room (environment) and involves various objects, including a special object to be weighed (TestObject), a scale (Scale), and other objects that may serve as distractors. The player acts as an agent within this environment, capable of performing a set of actions to interact with these objects. Below is a detailed description of each action, its constraints, and how it changes the game state:\n\n### Actions:\n\n1. **Look/Look Around**\n   - **Constraints:** None.\n   - **Effect:** Provides a description of the current environment, listing all visible objects and their states.\n   \n2. **Inventory**\n   - **Constraints:** None.\n   - **Effect:** Lists all items currently held by the player (in the agent's inventory).\n\n3. **Examine [object]**\n   - **Constraints:** The object must be visible to the player or in their inventory.\n   - **Effect:** Gives a detailed description of the specified object, including its properties (e.g., weight for TestObject).\n\n4. **Take [object]**\n   - **Constraints:** The object must be movable and not already in the player's inventory.\n   - **Effect:** Moves the specified object from its current location (or container) into the player's inventory.\n\n5. **Put [object] in/on [container]**\n   - **Constraints:** The object must be in the player's inventory, and the container must be able to hold objects. If the container can be opened or closed, it must be open.\n   - **Effect:** Moves the specified object from the player's inventory into the specified container.\n\n6. **Answer [weight]**\n   - **Constraints:** The player must specify a weight in grams.\n   - **Effect:** The player submits their guess for the weight of the target object. This action concludes the game, determining whether the player's guess matches the actual weight of the target object.\n\n### Game State Changes:\n\n- **Taking and Putting Objects:** These actions change the location of objects within the game world, moving them between the environment, containers, and the player's inventory.\n- **Answering:** This action directly affects the game's outcome by comparing the player's guess to the target object's actual weight. A correct guess results in winning the game, while an incorrect guess concludes the game without a win.\n- **Looking and Examining:** While these actions do not alter the physical state of the game world, they provide information that may influence the player's decisions and strategies.\n\n### Additional Notes:\n\n- The game initializes with a random selection of objects to weigh, including one target object and several distractors. The target object's weight is also randomly determined.\n- The game supports dynamic interaction with objects, allowing for a variety of strategies in identifying and weighing the target object.\n- The game concludes either when the player correctly guesses the weight of the target object or makes an incorrect guess, with the game state reflecting the outcome (win/loss).\n\nThis simulation offers a straightforward yet engaging problem-solving task, requiring players to interact with objects in a virtual environment to achieve a specific goal.",
    "cooking": "The Python program provided is a text-based simulation game where the player is tasked with cooking a meal following instructions from a cookbook. The game is set in a kitchen environment and involves interacting with various objects such as ingredients, devices, and tools like knives. Here's a detailed breakdown of the actions available in the game, their constraints, and how they change the game state:\n\n### Actions\n\n1. **Look Around (`look`, `look around`)**: Allows the player to get a description of the current environment, listing all visible objects. No constraints.\n\n2. **Inventory (`inventory`)**: Displays the items currently held by the player. Useful for tracking which ingredients and tools are in the player's possession. No constraints.\n\n3. **Take (`take <object>`)**: Enables the player to pick up an object and add it to their inventory. The object must be in the current environment and not already in the player's inventory. Changes the game state by moving the object from the environment to the player's inventory.\n\n4. **Put (`put <object> in <container>`)**: Allows the player to place an object from their inventory into a container in the environment. The object must be in the player's inventory, and the target must be a container. Changes the game state by moving the object from the player's inventory to the specified container.\n\n5. **Slice/Dice/Chop (`slice/dice/chop <ingredient> with <knife>`)**: These actions are used to prepare ingredients with a knife. The player must have both the ingredient and the knife in their inventory. Changes the state of the ingredient to reflect the preparation method (sliced, diced, chopped).\n\n6. **Cook (`cook <ingredient> in <device>`)**: Cooks an ingredient using a device like a stove or oven. The ingredient must be in the player's inventory, and the cooking method must match the device's capability (e.g., frying on a stove). Changes the ingredient's state to cooked.\n\n7. **Read (`read <cook book>`)**: Displays the instructions contained within the cookbook. The cookbook must be in the player's inventory. No direct change to the game state, but provides information necessary to complete the game.\n\n8. **Prepare Meal (`prepare meal`)**: The final action to complete the game, indicating that the player has followed the cookbook's instructions and prepared the meal. This action can only be successfully performed if all ingredients have been correctly prepared as per the cookbook.\n\n### Constraints and State Changes\n\n- **Taking and Putting Objects**: Objects can only be taken if they are not already in the player's inventory and must be in the current environment. Putting objects requires the target to be a container and the object to be in the player's inventory.\n  \n- **Preparing Ingredients**: Ingredients must be in the player's inventory to be prepared (sliced, diced, chopped, or cooked). Each preparation action changes the state of the ingredient (e.g., from raw to sliced). Incorrect preparation or cooking methods can lead to game failure.\n\n- **Cooking with Devices**: Cooking actions are specific to the device used (e.g., frying on a stove). The ingredient's state changes to reflect the cooking method applied.\n\n- **Reading the Cookbook**: Provides the necessary instructions for preparing the meal. Essential for understanding which ingredients need to be prepared and how.\n\n- **Preparing the Meal**: Can only be successfully completed if all ingredients have been prepared according to the cookbook's instructions. This action concludes the game, with success determined by the correct preparation of all ingredients.\n\nThe game tracks the player's progress through a scoring system, rewarding actions that align with the cookbook's instructions and penalizing incorrect actions. The game concludes when the player either successfully prepares the meal following all instructions or fails by incorrectly preparing an ingredient.",
    "lit-lightbulb": "The Python program provided is a text-based simulation game where the player's objective is to light up a light bulb by creating a simple electrical circuit using a battery, wires, and the light bulb itself. Here's a breakdown of the actions available in the game, their constraints, and how they change the game state:\n\n### Actions\n\n1. **Look/Look Around**\n   - **Constraints**: None.\n   - **Effect**: Provides a description of the current environment, listing all visible objects and their states.\n\n2. **Inventory**\n   - **Constraints**: None.\n   - **Effect**: Lists all items currently in the player's inventory.\n\n3. **Take [Object]**\n   - **Constraints**: The object must be present in the current environment and not already in the player's inventory. Some objects may not be movable.\n   - **Effect**: Moves the specified object from the environment into the player's inventory. If the object is an electrical object and connected, it disconnects it from the circuit.\n\n4. **Put [Object] in/on [Container]**\n   - **Constraints**: The player must have the object in their inventory, and the target must be a container object in the environment.\n   - **Effect**: Moves the specified object from the player's inventory into the specified container in the environment.\n\n5. **Connect [Object1] [Terminal1] to [Object2] [Terminal2]**\n   - **Constraints**: Both objects must be electrical objects, and at least one of them should be a wire. The terminals specified must be valid for the objects.\n   - **Effect**: Establishes an electrical connection between the two specified terminals of the electrical objects. If either terminal is already connected, it disconnects before establishing the new connection.\n\n### Game State Changes\n\n- **Electrical Connections**: The game keeps track of electrical connections between objects. Connecting objects correctly is necessary to complete the circuit and light the bulb.\n- **Light Bulb State**: The light bulb has an \"on\" state that changes based on the circuit's completeness and correctness. If the bulb is correctly connected in a circuit with the battery, its state changes to \"on\", indicating the player has successfully completed the task.\n- **Inventory Changes**: Taking and putting objects changes the contents of the player's inventory and the environment.\n- **Game Over/Win Condition**: The game ends and is considered won when the light bulb is successfully lit, indicated by its \"on\" state being true.\n\n### Additional Notes\n\n- The game does not include distractor items or actions, focusing solely on the task of creating an electrical circuit.\n- The game uses a tick function to update the state of the light bulb based on the current electrical connections, simulating a basic electrical circuit's behavior.\n- The game supports basic container interactions, allowing objects to be placed in or taken from containers, although the primary focus is on creating the circuit.\n\nThis simulation game provides a simplified model of electrical circuits, focusing on the connectivity and interaction between electrical components to achieve a specific goal.",
    "make-ice-cubes": "The Python program provided is a text-based simulation game where the player's task is to make ice cubes. The game is set in a kitchen environment and involves interacting with various objects to achieve the goal. Here's a breakdown of the actions available in the game, their constraints, and how they change the game state:\n\n### Actions\n\n1. **Look/Examine**: Allows the player to get a description of their surroundings or a specific object. This action doesn't change the game state but provides information to the player.\n\n2. **Inventory**: Lists the items currently in the player's possession. This action is purely informational.\n\n3. **Take/Put Object**: These actions allow the player to move objects between their inventory and the game environment or within the environment itself. Constraints include the object's movability and whether containers are open or closed. Changing an object's location can affect the game state by enabling or preventing other actions.\n\n4. **Open/Close Container**: These actions change the state of containers (e.g., the freezer or ice cube tray) from open to closed or vice versa. Constraints include whether the object is openable. Changing a container's state can affect which objects are accessible for interaction.\n\n5. **Turn On/Off Device**: Applies to devices like the sink. Constraints include whether the device is activatable. Turning a device on or off can change the environment, such as adding water to objects in the sink when it's turned on.\n\n6. **Use X on Y**: This action involves using one object on another, though it's noted as unused in the context of making ice cubes. The constraints and effects would depend on the specific objects involved.\n\n7. **Eat Food**: A distractor action that allows the player to consume food items. This action might not directly contribute to the main task but can change the game state by removing the food item from the game.\n\n### Game State Changes\n\n- **Temperature Changes**: The freezer object decreases the temperature of items inside it each tick, potentially freezing water into ice. This is critical for achieving the game's goal.\n- **Water Addition**: Turning the sink on adds water to containers within it, which is necessary for filling the ice cube tray.\n- **Object Accessibility**: Opening or closing containers and moving objects can change what items are accessible for the player to interact with, directly impacting the player's ability to progress in the task.\n\n### High-Level Solution Procedure\n\nTo successfully make ice cubes, the player needs to:\n1. Fill the ice cube tray with water from the sink, which involves turning on the sink and placing the tray in the sink.\n2. Put the filled ice cube tray in the freezer and ensure the freezer is closed.\n3. Wait for the water to freeze, which happens automatically as game ticks progress and the freezer lowers the temperature of the tray's contents.\n\nThe game's state changes based on these actions, moving towards the goal of creating ice cubes. The game is won when the ice cube tray contains ice, indicating the water has frozen.",
    "plant-tree": "The Python program provided is a text-based simulation game where the player's task is to plant a tree in a garden environment. The game involves interacting with various objects and performing actions that affect the game state. Here's a breakdown of the actions described in the code, their constraints, and how they change the game state:\n\n### Actions\n\n1. **look/look around**: \n   - **Constraints**: None.\n   - **Effect**: Provides a description of the current environment or room, listing visible objects and their states.\n\n2. **inventory**: \n   - **Constraints**: None.\n   - **Effect**: Lists the items currently in the player's inventory.\n\n3. **take [object]**: \n   - **Constraints**: The object must be in the same container (room or object) as the player and must be movable.\n   - **Effect**: Moves an object from its current location to the player's inventory.\n\n4. **put [object] in/on [container]**: \n   - **Constraints**: The player must have the object in their inventory, and the target must be a container that is open or can hold items.\n   - **Effect**: Moves an object from the player's inventory to the specified container.\n\n5. **turn on [device]/turn off [device]**: \n   - **Constraints**: The device must be activatable (e.g., a sink).\n   - **Effect**: Changes the state of a device to on or off. For example, turning on a sink can fill containers in the sink with water.\n\n6. **dig with [tool]**: \n   - **Constraints**: The tool must be a shovel, and it must be in the player's inventory.\n   - **Effect**: Creates a hole in the garden and adds soil to the player's inventory.\n\n7. **pour [water] into [container/water container/soil]**: \n   - **Constraints**: The water must be in a container that the player is interacting with, and the target must be capable of receiving water (e.g., a water container or soil).\n   - **Effect**: Transfers water to the target, potentially making soil wet if the target is soil.\n\n### Game State Changes\n\n- **Objects and Containers**: The game world consists of objects that can be containers (e.g., a hole, sink, water container) or simple items (e.g., a shovel, tree, soil). Containers can hold other objects, and their state can change based on player actions (e.g., a sink can be turned on to fill containers with water).\n- **Environment**: The garden is the main environment where all objects are located. Player actions can modify the environment by adding or moving objects (e.g., digging a hole, planting a tree).\n- **Inventory Management**: The player has an inventory for carrying objects. Taking an object moves it to the inventory, and putting an object moves it from the inventory to a specified location.\n- **Task Completion**: The ultimate goal is to plant a tree and water it. This involves a series of actions including digging a hole, planting the tree, adding soil, and watering it. Successfully completing these actions in the correct order achieves the game's objective.\n\n### Additional Notes\n\n- **Game Progression**: The game tracks the number of steps taken, the current score, and whether the game has been won or lost based on the player's actions.\n- **Dynamic Environment**: The game environment can change dynamically with each action. For example, turning on a sink will add water to containers in the sink during each game tick.\n\nThis simulation game provides a simple yet interactive environment for players to engage with, demonstrating basic principles of object-oriented programming and game design.",
    "take-photo": "The Python program provided defines a text-based game where the player's task is to take a photo of a specific food item using a camera with specified settings for shutter speed, aperture, and ISO. The game environment is a kitchen containing various food items and a camera. The player can interact with objects in the environment through a set of actions. Below is a detailed description of each action, its constraints, and how it changes the game state:\n\n### Actions\n\n1. **look around**: Provides a description of the current environment, listing all visible objects and their states. No constraints.\n\n2. **inventory**: Lists all items currently in the player's inventory. No constraints.\n\n3. **examine [object]**: Provides a detailed description of a specified object. The object must be visible in the environment or in the player's inventory.\n\n4. **eat [food item]**: Consumes a specified food item, removing it from the game. The food item must be in the player's inventory.\n\n5. **open [container]**: Opens a specified container, allowing access to its contents. The container must be openable.\n\n6. **close [container]**: Closes a specified container. The container must be openable and previously opened.\n\n7. **take [object]**: Moves a specified object from the environment into the player's inventory. The object must be movable.\n\n8. **put [object] in [container]**: Moves a specified object from the player's inventory into a specified container. Both the object and the container must be in the player's inventory or environment, and the container must be open.\n\n9. **turn on [device]**: Activates a specified device. The device must be capable of being turned on.\n\n10. **turn off [device]**: Deactivates a specified device. The device must be capable of being turned off.\n\n11. **focus [object]**: Sets the camera's focus to a specified object. The camera must be in the player's inventory, and the object must be in the environment.\n\n12. **rotate [dial] [direction]**: Rotates a specified dial on the camera in a specified direction (clockwise or anticlockwise). The dial can be for shutter speed, ISO, or aperture. The camera must be in the player's inventory.\n\n13. **press shutter**: Takes a photo with the camera using its current settings. The camera must be in the player's inventory, and its focus must be set.\n\n### Game State Changes\n\n- **Taking an object** changes the object's location from the environment to the player's inventory.\n- **Opening or closing a container** changes its state from open to closed or vice versa, affecting whether its contents can be accessed.\n- **Eating a food item** removes it from the game.\n- **Turning a device on or off** changes its operational state.\n- **Focusing the camera** and **rotating dials** change the camera's settings, affecting the outcome of a photo.\n- **Taking a photo** creates a photo object with the current focus and camera settings. If the photo matches the task requirements (correct focus and settings for the specified food item), the game can be won.\n\n### Constraints\n\n- Actions like **eating**, **taking**, and **putting** objects have constraints based on the object's properties (e.g., whether it's food, movable, or a container).\n- **Opening**, **closing**, **turning on**, and **turning off** actions are constrained by the object's capabilities (whether it's openable or activatable).\n- Camera-related actions (**focus**, **rotate**, **press shutter**) require the camera to be in the player's inventory and have specific constraints (e.g., the focus must be set before taking a photo).\n\n### Winning the Game\n\nThe game is won by successfully taking a photo of the specified food item with the correct camera settings. If the player consumes the target food item or fails to meet the photo requirements, the game can be lost.",
    "sweep-floor": "The Python program provided is a text-based simulation game where the player's task is to clean up garbage in a room by sweeping it into a dustpan with a broom and then dumping it into a garbage can. The game involves interacting with various objects within a simulated environment to achieve this goal. Here's a breakdown of the actions available in the game, their constraints, and how they change the game state:\n\n### Actions\n\n1. **Look Around (`look`, `look around`)**:\n   - **Constraints**: None.\n   - **Effect**: Provides a description of the current environment, including visible objects and their states.\n\n2. **Inventory (`inventory`)**:\n   - **Constraints**: None.\n   - **Effect**: Lists the items currently in the player's inventory.\n\n3. **Take (`take <object>`)**:\n   - **Constraints**: The object must be movable and not already in the player's inventory.\n   - **Effect**: Moves an object from the environment or a container into the player's inventory.\n\n4. **Put (`put <object> in/on <container>`)**:\n   - **Constraints**: The player must have the object in their inventory, and the target must be a container that is open or always accessible.\n   - **Effect**: Moves an object from the player's inventory into a specified container in the environment.\n\n5. **Open (`open <container>`)**:\n   - **Constraints**: The container must be openable and not already open.\n   - **Effect**: Opens a closed container, allowing access to its contents or the ability to place items inside.\n\n6. **Close (`close <container>`)**:\n   - **Constraints**: The container must be openable and currently open.\n   - **Effect**: Closes an open container, securing its contents.\n\n7. **Sweep (`sweep <garbage> to <dustpan> with <broom>`)**:\n   - **Constraints**: The player must have both the broom and the dustpan in their inventory. The garbage must be on the ground (not already in a container).\n   - **Effect**: Moves garbage from the ground into the dustpan.\n\n8. **Dump (`dump <dustpan> to <garbage can>`)**:\n   - **Constraints**: The dustpan must contain garbage, and the garbage can must be open.\n   - **Effect**: Empties the contents of the dustpan into the garbage can.\n\n### Game State Changes\n\n- **Taking and Putting Objects**: Changes the location of objects between the environment, containers, and the player's inventory.\n- **Opening and Closing Containers**: Changes the accessibility of containers, affecting whether objects can be placed in or taken out.\n- **Sweeping and Dumping**: Specifically changes the location of garbage objects, moving them from the ground to the dustpan and finally to the garbage can, which is the main goal of the game.\n\n### Winning Condition\n\nThe game is won when all garbage objects have been successfully moved from the ground into the garbage can. The game tracks this state and sets the `gameOver` and `gameWon` flags accordingly when the condition is met.\n\n### Additional Notes\n\n- The game includes a scoring system, though the provided code snippet primarily focuses on completing the task rather than accumulating points.\n- The game supports a dynamic set of actions based on the current state, including the objects present and their states (e.g., open or closed containers).\n- The game includes a placeholder for an agent (the player) as a special container for inventory management.",
    "balance-scale-heaviest": "The Python program provided defines a text-based game where the player's objective is to find the heaviest cubes using a balance scale and place them into a box. The game environment consists of a room containing a balance scale, cubes of different weights, and a box to place the heaviest cubes in. The game is designed to simulate a simple physics experiment and test the player's ability to deduce weight differences through comparison.\n\nHere's a breakdown of the actions described in the comments and how they affect the game state:\n\n### Actions:\n1. **look**: Allows the player to get a description of their current environment or inspect objects more closely. This action does not change the game state but provides information to the player.\n   - **Constraints**: None. Can be used at any time to gather information.\n   - **Game State Change**: No change.\n\n2. **inventory**: Displays the items currently held by the player (in their inventory).\n   - **Constraints**: None. Can be used at any time to view the player's inventory.\n   - **Game State Change**: No change.\n\n3. **take/put object**: These actions allow the player to interact with objects within the game world. The player can take objects and place them in their inventory or put objects from their inventory into other objects (like placing cubes on the balance scale or into the box).\n   - **Constraints**: \n     - Objects must be movable for the player to take them.\n     - The player can only put objects into containers (e.g., the balance scale sides, the box).\n     - Some objects, like the balance scale, have specific rules for interaction (e.g., objects cannot be placed directly on the balance scale but on its sides).\n   - **Game State Change**: \n     - Taking an object moves it from the environment (or a container within the environment) to the player's inventory.\n     - Putting an object moves it from the player's inventory to another location in the environment or a container.\n\n### Game State Changes in Detail:\n- **Taking an object**: Removes the object from its current location (the room or a container within the room) and adds it to the player's inventory.\n- **Putting an object on the balance scale**: The player must specify which side of the balance scale to place the object on. This action is used to compare weights of the cubes. The game state changes by updating the weight distribution on the balance scale, which can provide clues to the player about which cube is heavier.\n- **Placing the heaviest cubes in the box**: Once the player determines the heaviest cubes, they must put these cubes into the box. Successfully doing so progresses the player towards completing the game's objective.\n\n### Additional Notes:\n- The game includes a scoring system and a game over condition, which are determined by whether the player successfully identifies and places all the heaviest cubes into the box. Placing any non-heaviest cube in the box or failing to place all heaviest cubes results in game failure.\n- The game uses a random number generator to determine the number of cubes and their weights, adding variability to each game session.\n- The balance scale does not directly tell the weights but provides comparative feedback (e.g., one side is heavier/lighter or in balance), requiring the player to use logical deduction to identify the heaviest cubes.\n\nThis game simulates a simple problem-solving task within a constrained environment, focusing on logical deduction, inventory management, and understanding of basic physics (weight comparison) through text-based interaction.",
    "dishwasher": "The Python program provided simulates a text-based game where the player's task is to wash dirty dishes using a dishwasher. The game includes various actions that the player can perform, each affecting the game state in different ways. Here's a breakdown of the actions based on the code:\n\n### 1. Look\n- **Constraints**: None.\n- **Game State Change**: Provides a description of the current environment or a detailed description of an object when examined.\n  \n### 2. Inventory\n- **Constraints**: None.\n- **Game State Change**: Lists the items currently in the player's inventory.\n\n### 3. Take/Put Objects\n- **Constraints**: Objects must be moveable to be taken. To put an object, the destination must be a container and, if it's closeable, it must be open.\n- **Game State Change**: Moves objects between the environment, the player's inventory, and other containers.\n\n### 4. Open/Close Containers\n- **Constraints**: Containers must have the \"isOpenable\" property set to True.\n- **Game State Change**: Changes the \"isOpen\" state of containers, affecting whether objects can be placed in or taken out.\n\n### 5. Turn On/Off Devices\n- **Constraints**: Devices must have the \"isActivatable\" property set to True.\n- **Game State Change**: Changes the \"isOn\" state of devices, affecting their operation (e.g., the dishwasher washing dishes).\n\n### 6. Use X on Y\n- **Constraints**: Depends on the objects involved. For example, using dish soap on a dish or the dishwasher.\n- **Game State Change**: Can add soap to dishes or the dishwasher, affecting whether dishes can be cleaned.\n\n### 7. Eat Food\n- **Constraints**: Food must be in the player's inventory, and a clean dish must be used.\n- **Game State Change**: Consumes the food item and dirties the dish used.\n\n### Distractor Actions:\n- **Eating food** is a distractor action that doesn't contribute directly to the main task of washing dishes but changes the game state by dirtying dishes.\n\n### High-level Solution Procedure:\n1. **Put dirty dishes inside the dishwasher**: Requires opening the dishwasher, taking dishes, and putting them inside.\n2. **Add soap**: Involves taking the dish soap and using it on the dishwasher.\n3. **Turn on the dishwasher**: The dishwasher must be closed and then turned on. The game simulates the washing process over time.\n4. **Wait for the cycle to finish**: The dishwasher's state changes to indicate when the cycle is complete and dishes are clean.\n\n### Game State Changes:\n- **Dishes**: Can be dirty or clean. Washing them changes their state to clean.\n- **Dishwasher**: Has stages indicating whether it's running, finished, or ready to be unloaded.\n- **Soap**: Using soap on dishes or the dishwasher is necessary for cleaning dishes.\n\nThe game progresses through player actions, with the environment responding accordingly. The goal is to clean all the dirty dishes, with the game tracking the player's actions and providing feedback on the current state of the kitchen, the dishwasher, and the dishes.",
    "volume-container": "The Python program provided simulates a text-based game where the player's task is to determine the volume of a specific water container by conducting an experiment involving water, a sink, various containers, and a graduated cylinder. Here's a breakdown of the actions available in the game, their constraints, and how they change the game state:\n\n### Actions\n\n1. **Look/Look Around**\n   - **Constraints**: None.\n   - **Effect**: Provides a description of the current environment, including objects present and their state.\n\n2. **Inventory**\n   - **Constraints**: None.\n   - **Effect**: Lists the items currently in the player's inventory.\n\n3. **Take [Object]**\n   - **Constraints**: The object must be movable and not a liquid.\n   - **Effect**: Moves an object from its current location to the player's inventory.\n\n4. **Put [Object] in [Container]**\n   - **Constraints**: The object must be in the player's inventory, and the target must be a container that is not specifically for liquids unless the object is water.\n   - **Effect**: Moves an object from the player's inventory to a specified container in the environment.\n\n5. **Turn On [Device]**\n   - **Constraints**: The device must be activatable (e.g., the sink).\n   - **Effect**: Activates a device, which can change its state or affect other objects (e.g., filling containers with water if the sink is turned on).\n\n6. **Turn Off [Device]**\n   - **Constraints**: The device must be activatable.\n   - **Effect**: Deactivates a device, stopping its active effects.\n\n7. **Pour [Liquid] into [Container]**\n   - **Constraints**: The source must contain a liquid, and the target must be a container that can hold liquid.\n   - **Effect**: Transfers liquid from one container to another, adjusting the volume of liquid in each based on their capacities.\n\n8. **Answer [Volume]**\n   - **Constraints**: The volume must be a number.\n   - **Effect**: The player submits their guess for the volume of the target container. This ends the game and determines if the player has won based on the accuracy of their answer.\n\n### Game State Changes\n\n- **Objects and Containers**: Objects can be moved between the environment, the player's inventory, and other containers. Containers can have their contents and states (e.g., open/closed, on/off) changed.\n- **Water Volume**: The volume of water in containers can change, especially with the \"pour\" action or when the sink fills containers.\n- **Game Progression**: The game tracks the player's actions, updating the environment and the task's progress accordingly. The game ends when the player submits an answer for the volume of the target container.\n- **Scoring and Winning**: The game is won if the player correctly identifies the volume of the target container. The score reflects the player's success in achieving the game's goal.\n\nThis game emphasizes understanding and manipulating the states of objects within a simulated environment to achieve a specific goal, showcasing basic principles of volume measurement and fluid dynamics within a text-based simulation framework.",
    "balance-scale-weigh": "The Python program provided is a text-based simulation game where the player's task is to determine the weight of a cube using a balance scale. The game is set in a single room environment containing various objects, including a balance scale, weights, a cube, and a box. The player interacts with the game through a set of defined actions, which manipulate the game state and objects within the environment. Below is a detailed description of all actions available in the game, their constraints, and how they change the game state:\n\n### Actions\n\n1. **Look (around)**\n   - **Constraints:** None.\n   - **Effect:** Provides a description of the current environment, listing all visible objects and their states. This action does not change the game state but gives the player information about the environment.\n\n2. **Inventory**\n   - **Constraints:** None.\n   - **Effect:** Lists all items currently in the player's inventory. This action does not change the game state but informs the player about the items they have collected.\n\n3. **Take [object] (from [container])**\n   - **Constraints:** The object must be movable and contained within the specified container or the environment. The container (if specified) must be open or openable.\n   - **Effect:** Moves an object from its current location (a container or the environment) into the player's inventory. This action changes the game state by altering the location of an object.\n\n4. **Put [object] in/on [container]**\n   - **Constraints:** The object must be in the player's inventory, and the target container must be able to hold objects (i.e., it must be a container object that is open or openable).\n   - **Effect:** Moves an object from the player's inventory to a specified container in the environment. This action changes the game state by altering the location of an object.\n\n5. **Answer [weight]**\n   - **Constraints:** The weight must be a valid integer representing the player's guess for the cube's weight.\n   - **Effect:** The player submits their guess for the weight of the cube. If the guess matches the actual weight of the cube, the game is won; otherwise, the game is lost. This action concludes the game by setting the `gameOver` flag to True and the `gameWon` flag to True or False based on the correctness of the answer.\n\n### Game State Changes\n\n- **Taking and putting objects:** These actions directly modify the game state by changing the location of objects between the environment, containers, and the player's inventory. They can affect the player's ability to perform other actions, especially those requiring specific objects to be in specific locations (e.g., weighing objects on the balance scale).\n  \n- **Answering:** This action concludes the game by evaluating the player's guess against the actual weight of the cube. The game state is significantly changed by setting the `gameOver` and `gameWon` flags, indicating the end of the game and the outcome.\n\n### Additional Notes\n\n- The game employs a random element in determining the weight of the cube, adding variability to each game session.\n- The balance scale does not directly interact with the \"put\" and \"take\" actions in a conventional manner. Instead, objects must be placed on either side of the scale, and the game implicitly calculates the mass based on the objects' `weight` properties.\n- The game includes a scoring system, where successfully determining the cube's weight results in a score increase. Incorrect answers or actions do not seem to penalize the player's score but will end the game.\n- The game's environment is dynamic, with the potential for objects to be moved around, affecting the available actions and their outcomes.",
    "refrigerate-food": "The Python program provided is a text-based simulation game where the player's objective is to prevent food items from spoiling by managing them within a simulated kitchen environment. The game involves interacting with various objects, including a fridge, food items, and a counter, through a set of defined actions. Here's a breakdown of the actions, their constraints, and how they change the game state:\n\n### Actions:\n\n1. **look/look around**: Allows the player to get a description of their current environment, listing visible objects and their states. No constraints.\n\n2. **inventory**: Displays the items currently held by the player (in their inventory). No constraints.\n\n3. **examine [object]**: Provides detailed information about a specific object. The object must be visible to the player.\n\n4. **take [object]**: Moves an object from its current location (e.g., the counter) to the player's inventory. The object must be movable and accessible (not inside a closed container).\n\n5. **put [object] in/on [container]**: Transfers an object from the player's inventory to a specified container (e.g., fridge). The container must be openable and currently open.\n\n6. **open [container]**: Opens a container if it is closed and openable. This action is necessary to access or modify the contents of containers like the fridge.\n\n7. **close [container]**: Closes an open container. This might be necessary to activate certain effects, like cooling food in the fridge.\n\n8. **turn on [device]**: Activates a device. In this game, the fridge is always on and cannot be turned off, making this action irrelevant.\n\n9. **turn off [device]**: Deactivates a device. Since the fridge cannot be turned off, this action is also irrelevant.\n\n10. **eat [food item]**: Consumes a food item from the player's inventory. This action removes the food item from the game.\n\n11. **use [object] on [target]**: A general action for using one object on another. This action is listed as a distractor and does not have a specific function in the game.\n\n### Constraints and State Changes:\n\n- **Fridge**: Can be opened/closed. Affects the temperature of items inside, preventing them from spoiling. Must be closed to cool items.\n- **Food Items**: Have a spoil time and a maximum temperature before they start spoiling. Moving them into the fridge prevents spoiling.\n- **Counter**: Acts as a place to find or place items but does not affect their state.\n- **Temperature Management**: Food items and the fridge interact through temperature. Food items above their max temperature will spoil unless placed in the fridge.\n- **Spoilage**: Food items track time above their max temperature. If this exceeds their spoil time, they become spoiled, affecting the game's outcome.\n\n### Game Outcome:\n\nThe game is won by preventing all food items from spoiling, primarily by using the fridge effectively. The game tracks steps, score, and whether the game has been won or lost based on the player's actions and their effects on the food items' states.",
    "multimeter": "The Python program provided simulates a text-based game where the player's task is to measure the resistance of a specific resistor using a multimeter. The game environment consists of a room containing a multimeter, several resistors (one of which is the target), and wires. The player interacts with the game through a series of text commands to manipulate objects and achieve the goal. Below is a detailed description of each action, its constraints, and how it changes the game state:\n\n### Actions\n\n1. **look/look around**: \n   - **Constraints**: None.\n   - **Effect**: Provides a description of the current environment, listing all visible objects in the room.\n\n2. **inventory**: \n   - **Constraints**: None.\n   - **Effect**: Lists all items currently in the player's inventory.\n\n3. **take object**: \n   - **Constraints**: The object must be present in the room and not already in the player's inventory.\n   - **Effect**: Moves an object from the room into the player's inventory. If the object is an electrical object, all its connections are removed.\n\n4. **put object in container**: \n   - **Constraints**: The object must be in the player's inventory, and the target must be a container object.\n   - **Effect**: Moves an object from the player's inventory into a specified container in the room.\n\n5. **set multimeter to mode X**: \n   - **Constraints**: The mode must be one of \"voltage\", \"current\", or \"resistance\". The multimeter must be in the player's inventory or the room.\n   - **Effect**: Changes the mode of the multimeter to the specified mode. This is critical for measuring resistance accurately.\n\n6. **connect X terminal A to Y terminal B**: \n   - **Constraints**: Both X and Y must be electrical objects (e.g., a multimeter, a wire, or a resistor) with available terminals. At least one of the objects should be a wire or the multimeter.\n   - **Effect**: Establishes a connection between two electrical objects. This is necessary to create a circuit for measuring resistance.\n\n7. **answer**: \n   - **Constraints**: The player must provide a numerical value representing the resistance they believe the target resistor has.\n   - **Effect**: Submits the player's answer. The game checks if the answer matches the target resistor's resistance. If correct, the game is won; otherwise, it ends in failure.\n\n### Game State Changes\n\n- **Objects**: Objects can be moved between the room, containers, and the player's inventory. Electrical objects can be connected or disconnected, affecting their description and how they interact with the multimeter.\n- **Multimeter Mode**: The multimeter's mode affects its functionality. Only in resistance mode can it measure resistance accurately.\n- **Connections**: Creating connections between objects is necessary to form a circuit. The game likely tracks these connections to determine if a complete circuit exists for measuring resistance.\n- **Game Progress**: The game tracks the player's actions, updating the game state with each command. The player's goal is to correctly identify the resistance of the target resistor, which requires setting up the multimeter correctly and forming the right connections.\n- **Game End Conditions**: The game ends when the player submits an answer. The outcome (win/lose) depends on the accuracy of the resistance value provided.\n\nThis game simulates the process of using a multimeter to measure resistance, requiring the player to understand basic principles of electrical circuits and multimeter operation.",
    "bath-tub-water-temperature": "The Python program provided is a text-based simulation game where the player's objective is to adjust the water temperature in a bathtub to a comfortable range (35-40 degrees Celsius) for taking a bath. The game environment is a bathroom, and the player interacts with objects such as taps, a thermometer, water, and the bathtub itself to achieve the goal. Here's a breakdown of the actions available in the game, their constraints, and how they change the game state:\n\n### Actions\n\n1. **Look/Look Around**: \n   - **Constraints**: None.\n   - **Effect**: Provides a description of the current environment or the state of a specific object.\n   \n2. **Inventory**: \n   - **Constraints**: None.\n   - **Effect**: Lists the items currently in the player's possession.\n   \n3. **Take/Put Objects**: \n   - **Constraints**: Objects must be movable to be taken. To put an object somewhere, the destination must be a container and, if it's openable, it must be open.\n   - **Effect**: Changes the location of an object from the environment to the player's inventory or from the player's inventory to another location in the environment.\n   \n4. **Turn On/Off Devices (Taps)**: \n   - **Constraints**: The object must be activatable.\n   - **Effect**: Changes the state of a tap to either on or off, affecting the water flow and temperature in the bathtub.\n   \n5. **Use Device on Objects (Use Thermometer on Water)**: \n   - **Constraints**: The device must be usable, and the target object must be appropriate for the device (e.g., using a thermometer on water).\n   - **Effect**: Provides information or changes the state of the target object based on the device used (e.g., reading the water temperature).\n   \n6. **Bath**: \n   - **Constraints**: The action to take a bath can be performed at any time, but the game's objective is to do so when the water temperature is within the desired range.\n   - **Effect**: Ends the game. The player wins if the water temperature is within the comfortable range (35-40 degrees Celsius); otherwise, the player loses.\n\n### Game State Changes\n\n- **Water Temperature Adjustment**: Turning on the hot or cold tap will adjust the water temperature in the bathtub. The game simulates this by changing the water's temperature property based on whether the hot or cold tap is turned on and its current temperature.\n- **Inventory Management**: Taking or putting objects changes the player's inventory contents and the environment's state by moving objects between the player and the environment.\n- **Information Gathering**: Using the thermometer on the water provides the player with the current water temperature, crucial for deciding whether to add more hot or cold water.\n\n### Winning Condition\n\nThe game is won by adjusting the water temperature to the desired range (35-40 degrees Celsius) and then choosing to take a bath. The game checks the water temperature in the bathtub when the \"bath\" action is performed and determines if the player has won or lost based on the temperature.\n\nThis game emphasizes object interaction and state management within a simulated environment, providing a simple yet engaging puzzle for the player to solve.",
    "sunburn": "Based on the provided Python code for a text-based game, here are the actions a player can take, along with their constraints and how they change the game state:\n\n### 1. Look Around\n- **Action**: `look around` or `look`\n- **Constraints**: None. This action can be performed in any state.\n- **Game State Change**: Provides a description of the current room, including visible items and exits.\n\n### 2. Inventory\n- **Action**: `inventory`\n- **Constraints**: None. This action can be performed at any time to check the player's inventory.\n- **Game State Change**: Lists the items currently in the player's inventory.\n\n### 3. Take\n- **Action**: `take <item>`\n- **Constraints**: The item must be in the same room as the player and must be movable.\n- **Game State Change**: Moves an item from the room into the player's inventory.\n\n### 4. Put\n- **Action**: `put <item> in <container>`\n- **Constraints**: The item must be in the player's inventory, and the target must be a container in the same room as the player. The container must be open or openable.\n- **Game State Change**: Moves an item from the player's inventory into a container in the room.\n\n### 5. Use\n- **Action**: `use <item>`\n- **Constraints**: The item must be usable and in the player's inventory. For example, using sunscreen prevents sunburn.\n- **Game State Change**: Applies the effect of the item. Using sunscreen sets the `use_sunscreen` property of the agent to `True`, preventing sunburn.\n\n### 6. Move\n- **Action**: `move to <room>`\n- **Constraints**: The target room must be directly connected to the current room.\n- **Game State Change**: Changes the player's current location to the target room.\n\n### Additional Notes:\n- **Sunburn Mechanism**: If the player moves to an outdoor room without using sunscreen, they will get sunburned, which is checked on every tick of the game's internal clock. Getting sunburned ends the game with a loss.\n- **Winning Condition**: To win the game, the player must take a ball from the beach and put it in a box in the house without getting sunburned.\n- **Game Over Conditions**: The game ends when the player gets sunburned or successfully completes the task of moving the ball to the box.\n\nThis game simulates a simple task with a focus on inventory management and the use of items to alter the state of the player or the environment. The primary goal is to encourage strategic thinking about when and how to use items to achieve the objective while avoiding negative states like sunburn."
}